corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 45)
coffee <- subset (df,
select = -c(owner
,farm_name
,lot_number
,mill
,ico_number
,company
,altitude
,region
,producer
,number_of_bags
,bag_weight
,in_country_partner
,harvest_year
,grading_date
,owner_1
,expiration
,certification_body
,certification_address
,certification_contact
,unit_of_measurement
,aroma
,flavor
,aftertaste
,acidity
,body
,balance
,uniformity
,clean_cup
,sweetness
,cupper_points
,altitude_low_meters
,altitude_high_meters
))
coffee <- coffee %>%
mutate(processing_method =
ifelse(is.na(processing_method), "Washed / Wet", processing_method))
# Trocar NA por "Green"
coffee <- coffee %>%
mutate(color = ifelse(is.na(color), "Green", color))
# Preenchimento dos NA com a média de acordo com o país
coffee <- coffee %>%
group_by(country_of_origin) %>%
mutate(altitude_mean_meters = ifelse(is.na(altitude_mean_meters),
mean(altitude_mean_meters, na.rm = TRUE),
altitude_mean_meters))
# Trocando "NA" por "0"
coffee <- coffee %>%
mutate(quakers = ifelse(is.na(quakers), 0, quakers))
# Criando faixas de corte (Faixas reconhecida internacionalmente)
coffee$specialty_coffee <-
ifelse(coffee$total_cup_points < 80, 1,
ifelse(coffee$total_cup_points >= 80 & coffee$total_cup_points < 85, 2,
ifelse(coffee$total_cup_points >= 85 & coffee$total_cup_points < 90, 3,
4)))
# Retirando dados NA da variavel "country_of" pois tem a mesma qtd das demais
coffee_01 <- coffee[complete.cases(coffee$country_of_origin), ]
view(coffee_01)
contagem_faixas <- table(coffee_01$specialty_coffee)
barplot(prop.table(contagem_faixas) * 100, main = "Porcentagem de Faixa de score",
xlab = "Faixa de score", ylab = "Porcentagem", col = "green")
# Gráfico com o % de variáveis NA
colunas_na <- colSums(is.na(coffee_01))
info_na <- colunas_na[colunas_na > 0] # 4 colunas com NA
porcent_NA <- info_na / nrow(coffee_01) * 100
barplot(porcent_NA, main = "Porcentagem de NA por Coluna",
ylab = "Porcentagem de NA", xlab = "Colunas",
col = "blue", las = 2)  # las = 2 para rotacionar os rótulos do eixo x
info_na
dados <- coffee_01
colunas_nao_numericas <- sapply(dados, class) != "numeric"
dados_numericos <- dados[, !colunas_nao_numericas]
matrix_de_correlacao <- cor(dados_numericos)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 45)
df <- read.csv("https://raw.githubusercontent.com/mconjaud/TrabalhoFinalAEM2/main/Estatistica/coffee_ratings.csv")
library(MASS)
library(tidyverse)
library(keras)
library(rsample)
library(keras)
library(yardstick)
library(skimr)
library(dplyr)
library(GGally)
library(ggrepel)
library(factoextra)
library(countrycode)
library(dplyr)
library(tidymodels)
library(tidyverse)
library(ISLR)
library(vip)
library(doParallel)
library(skimr)
df <- read.csv("https://raw.githubusercontent.com/mconjaud/TrabalhoFinalAEM2/main/Estatistica/coffee_ratings.csv")
# Calculando a proporção de valores missing por variável
prop_missing <- df %>%
summarise_all(~ mean(is.na(.))) %>%
gather() %>%
arrange(desc(value))
grafico <- ggplot(prop_missing, aes(x = reorder(key, -value), y = value)) +
geom_bar(stat = "identity", fill = "skyblue") +
coord_flip() +  # Rotaciona as barras para torná-las horizontais
labs(x = "Variável", y = "% de Valores missing",
title = "% de Valores missing por Variável")
print(grafico)
# Gráfico com o % de variáveis NA
colunas_na <- colSums(is.na(df))
info_na <- colunas_na[colunas_na > 0] # 4 colunas com NA
porcent_NA <- info_na / nrow(df) * 100
barplot(porcent_NA, main = "Porcentagem de NA por Coluna",
ylab = "Porcentagem de NA", xlab = "Colunas",
col = "blue", las = 2)  # las = 2 para rotacionar os rótulos do eixo x
library(MASS)
library(tidyverse)
library(keras)
library(rsample)
library(keras)
library(yardstick)
library(skimr)
library(dplyr)
library(GGally)
library(ggrepel)
library(factoextra)
library(countrycode)
library(dplyr)
library(tidymodels)
library(tidyverse)
library(ISLR)
library(vip)
library(doParallel)
library(skimr)
#### TRAZENDO A BASE PARA PREDIÇÃO
# Upload do Data Frame
df <- read.csv("https://raw.githubusercontent.com/mconjaud/TrabalhoFinalAEM2/main/Estatistica/coffee_ratings.csv")
#### ANALIZANDO A BASE ############
View(df) #Vizualizando a base
str(df)  # Tipo da variavel
skim(df) # % de missings
## troquei o gráfico por um mais 'bonito'
# Gráfico com o % de variáveis NA
colunas_na <- colSums(is.na(df))
info_na <- colunas_na[colunas_na > 0] # 4 colunas com NA
porcent_NA <- info_na / nrow(df) * 100
barplot(porcent_NA, main = "Porcentagem de NA por Coluna",
ylab = "Porcentagem de NA", xlab = "Colunas",
col = "blue", las = 2)  # las = 2 para rotacionar os rótulos do eixo x
#### TRATANDO A BASE ANTES DE APLICAR MODELOS ############
# Removendo as linhas com missing values da coluna country_of_origin, pois essa linha tem pouca informação
df <- df[complete.cases(df$country_of_origin), ]
# Removendo as variáveis que não serão utilizadas para as duas análises (supervisionada e não supervisionada)
coffee <- subset (df,
select = -c(owner
,farm_name
,lot_number
,mill
,ico_number
,company
,altitude
,region
,producer
,number_of_bags
,bag_weight
,in_country_partner
,harvest_year
,grading_date
,owner_1
#,variety
,expiration
,certification_body
,certification_address
,certification_contact
,altitude_low_meters
,altitude_high_meters))
# Trocar missing por "Washed / Wet"
unique(coffee$processing_method)
coffee <- coffee %>%
mutate(processing_method =
ifelse(is.na(processing_method), "Washed / Wet", processing_method))
# Trocar missing por "Green"
unique(coffee$color)
coffee <- coffee %>%
mutate(color = ifelse(is.na(color), "Green", color))
#---------------------------------------------------------------------
#Deixei comentado os códigos abaixo, pois acho que teremos que converter mesmo de pés para metros
# Padronizar "unit_of_measurement" em metros
#unique(coffee$unit_of_measurement)
#view(coffee$unit_of_measurement)
#coffee <- coffee %>%
#  mutate(unit_of_measurement =
#           ifelse(unit_of_measurement == "ft", "m", unit_of_measurement))
#---------------------------------------------------------------------
#Converte a coluna altitude_mean_meters de pés para metros
coffee<- coffee %>%
mutate(altitude_mean_meters = ifelse(unit_of_measurement == "ft", altitude_mean_meters * 0.3048, altitude_mean_meters))
# há problema de qualidade dos dados, pois há medidas acima dos 10000 (mais alto que o Everest).
#Assim, vamos dividir esses valores por 100 (valores acima dos 100.000) e por 10 (acima dos 5000), nesse sequência.
coffee<- coffee %>%
mutate(altitude_mean_meters = ifelse(altitude_mean_meters > 100000, altitude_mean_meters/100, altitude_mean_meters))
coffee<- coffee %>%
mutate(altitude_mean_meters = ifelse(altitude_mean_meters > 5000, altitude_mean_meters/10, altitude_mean_meters))
# Preenchimento dos missings da coluna altitude_mean_meters pela média por país
coffee <- coffee %>%
group_by(country_of_origin) %>%
mutate(altitude_mean_meters = ifelse(is.na(altitude_mean_meters),
mean(altitude_mean_meters, na.rm = TRUE),
altitude_mean_meters))
#---------------------------------------------------------------------
#Deixei comentado os códigos abaixo, pois substitui os missing values da coluna variety pela moda por país
# substituindo missing values da
# Trocando "NA" por "other" em variety
#coffee$variety_index <- match(df$variety, unique(df$variety)) # criando indice
#coffee$variety <- ifelse(is.na(coffee$variety), "Other", coffee$variety)
#quantidade_other <- table(coffee$variety)["Other"] #336 vezes
#---------------------------------------------------------------------
# Substitui os valores ausentes em quakes pela moda
coffee$quakers <- ifelse(is.na(coffee$quakers),
names(sort(-table(coffee$quakers)))[1], #calcula a moda
coffee$quakers)
#Tratamento dos missing values da coluna variety': vamos substituir pelo valor mais frequente por país
# A Costa do Marfim, Equador, Mauricios e Papua Nova Guine só possuem um café avaliado e não possui valores de variety.
#Assim, vamos usar a moda da coluna para esses países
coffee$variety <- ifelse(coffee$country_of_origin == "Cote d?Ivoire" |
coffee$country_of_origin == "Ecuador" |
coffee$country_of_origin == "Mauritius"|
coffee$country_of_origin == "Papua New Guinea",
names(sort(-table(coffee$variety)))[1], #calcula a moda
coffee$variety)
# Cria uma tabela com a moda de variety por country_of_origin
moda_por_regiao <- coffee %>%
group_by(country_of_origin) %>%
summarise(moda_variety = names(sort(-table(variety)))[1])
moda_por_regiao <- na.omit(moda_por_regiao)
# Substitui os valores ausentes pelo valor mais frequente na região
coffee <- coffee %>%
group_by(country_of_origin) %>%
mutate(variety = ifelse(is.na(variety), moda_por_regiao$moda_variety[match(country_of_origin, moda_por_regiao$country_of_origin)], variety))
sum(is.na(coffee$variety))
#---------------------------------------------------------------------
## não achei a forma de trocar pela mediada ... ainda buscando :(
## Comentário Flávio: resolvi acima
### S2
# Criando a coluna continentes de acordo com o nome do country
## Comentário Flávio: precisamos da uma coluna chamada continente? Fiquei na dúvida
### na ultima versão que eu fiz eu havia retirado, realmente não agrega, vou comentar
#coffee$continent <-
#  countrycode(sourcevar = coffee$country_of_origin,
#              origin = "country.name", destination = "continent")
#---------------------------------------------------------------------
view(coffee)
#Removendo a coluna unit_of_measurement (não precisaremos dela)
coffee <- subset(coffee, select = -c(unit_of_measurement))
#---------------------------------------------------------------------
# não entendo a inclusão de "idade"
## Comentário Flávio: acho que não faz sentido também. Aí deixei comentado.
# Adding a new column called "Age"
#df <- mutate(df, Age = c(25, 30, 22, 28, 35))
#---------------------------------------------------------------------
## Criar a coluna chamada Grade com a classificação dos cafés
## Critério:
## < 70 - Ruim (será 0)
## 70>= e < 80 - Bom (será 1)
## 80>= e < 85 - Muito Bom (será 2)
## 85 >= - Excelente (será 3)
coffee$grade <- cut(coffee$total_cup_points,
breaks = c(-Inf, 70, 80, 85, Inf),
labels = c(0, 1, 2, 3),
right = FALSE)
library(MASS)
library(tidyverse)
library(keras)
library(rsample)
library(keras)
library(yardstick)
library(skimr)
library(dplyr)
library(GGally)
library(ggrepel)
library(factoextra)
library(countrycode)
library(dplyr)
library(tidymodels)
library(tidyverse)
library(ISLR)
library(vip)
library(doParallel)
library(skimr)
#### TRAZENDO A BASE PARA PREDIÇÃO
# Upload do Data Frame
df <- read.csv("https://raw.githubusercontent.com/mconjaud/TrabalhoFinalAEM2/main/Estatistica/coffee_ratings.csv")
#### ANALIZANDO A BASE ############
View(df) #Vizualizando a base
str(df)  # Tipo da variavel
skim(df) # % de missings
## troquei o gráfico por um mais 'bonito'
# Gráfico com o % de variáveis NA
colunas_na <- colSums(is.na(df))
info_na <- colunas_na[colunas_na > 0] # 4 colunas com NA
porcent_NA <- info_na / nrow(df) * 100
barplot(porcent_NA, main = "Porcentagem de NA por Coluna",
ylab = "Porcentagem de NA", xlab = "Colunas",
col = "blue", las = 2)  # las = 2 para rotacionar os rótulos do eixo x
#### TRATANDO A BASE ANTES DE APLICAR MODELOS ############
# Removendo as linhas com missing values da coluna country_of_origin, pois essa linha tem pouca informação
df <- df[complete.cases(df$country_of_origin), ]
# Removendo as variáveis que não serão utilizadas para as duas análises (supervisionada e não supervisionada)
coffee <- subset (df,
select = -c(owner
,farm_name
,lot_number
,mill
,ico_number
,company
,altitude
,region
,producer
,number_of_bags
,bag_weight
,in_country_partner
,harvest_year
,grading_date
,owner_1
#,variety
,expiration
,certification_body
,certification_address
,certification_contact
,altitude_low_meters
,altitude_high_meters))
# Trocar missing por "Washed / Wet"
unique(coffee$processing_method)
coffee <- coffee %>%
mutate(processing_method =
ifelse(is.na(processing_method), "Washed / Wet", processing_method))
# Trocar missing por "Green"
unique(coffee$color)
coffee <- coffee %>%
mutate(color = ifelse(is.na(color), "Green", color))
#---------------------------------------------------------------------
#Deixei comentado os códigos abaixo, pois acho que teremos que converter mesmo de pés para metros
# Padronizar "unit_of_measurement" em metros
#unique(coffee$unit_of_measurement)
#view(coffee$unit_of_measurement)
#coffee <- coffee %>%
#  mutate(unit_of_measurement =
#           ifelse(unit_of_measurement == "ft", "m", unit_of_measurement))
#---------------------------------------------------------------------
#Converte a coluna altitude_mean_meters de pés para metros
coffee<- coffee %>%
mutate(altitude_mean_meters = ifelse(unit_of_measurement == "ft", altitude_mean_meters * 0.3048, altitude_mean_meters))
# há problema de qualidade dos dados, pois há medidas acima dos 10000 (mais alto que o Everest).
#Assim, vamos dividir esses valores por 100 (valores acima dos 100.000) e por 10 (acima dos 5000), nesse sequência.
coffee<- coffee %>%
mutate(altitude_mean_meters = ifelse(altitude_mean_meters > 100000, altitude_mean_meters/100, altitude_mean_meters))
coffee<- coffee %>%
mutate(altitude_mean_meters = ifelse(altitude_mean_meters > 5000, altitude_mean_meters/10, altitude_mean_meters))
# Preenchimento dos missings da coluna altitude_mean_meters pela média por país
coffee <- coffee %>%
group_by(country_of_origin) %>%
mutate(altitude_mean_meters = ifelse(is.na(altitude_mean_meters),
mean(altitude_mean_meters, na.rm = TRUE),
altitude_mean_meters))
#---------------------------------------------------------------------
#Deixei comentado os códigos abaixo, pois substitui os missing values da coluna variety pela moda por país
# substituindo missing values da
# Trocando "NA" por "other" em variety
#coffee$variety_index <- match(df$variety, unique(df$variety)) # criando indice
#coffee$variety <- ifelse(is.na(coffee$variety), "Other", coffee$variety)
#quantidade_other <- table(coffee$variety)["Other"] #336 vezes
#---------------------------------------------------------------------
# Substitui os valores ausentes em quakes pela moda
coffee$quakers <- ifelse(is.na(coffee$quakers),
names(sort(-table(coffee$quakers)))[1], #calcula a moda
coffee$quakers)
#Tratamento dos missing values da coluna variety': vamos substituir pelo valor mais frequente por país
# A Costa do Marfim, Equador, Mauricios e Papua Nova Guine só possuem um café avaliado e não possui valores de variety.
#Assim, vamos usar a moda da coluna para esses países
coffee$variety <- ifelse(coffee$country_of_origin == "Cote d?Ivoire" |
coffee$country_of_origin == "Ecuador" |
coffee$country_of_origin == "Mauritius"|
coffee$country_of_origin == "Papua New Guinea",
names(sort(-table(coffee$variety)))[1], #calcula a moda
coffee$variety)
# Cria uma tabela com a moda de variety por country_of_origin
moda_por_regiao <- coffee %>%
group_by(country_of_origin) %>%
summarise(moda_variety = names(sort(-table(variety)))[1])
moda_por_regiao <- na.omit(moda_por_regiao)
# Substitui os valores ausentes pelo valor mais frequente na região
coffee <- coffee %>%
group_by(country_of_origin) %>%
mutate(variety = ifelse(is.na(variety), moda_por_regiao$moda_variety[match(country_of_origin, moda_por_regiao$country_of_origin)], variety))
sum(is.na(coffee$variety))
#---------------------------------------------------------------------
## não achei a forma de trocar pela mediada ... ainda buscando :(
## Comentário Flávio: resolvi acima
### S2
# Criando a coluna continentes de acordo com o nome do country
## Comentário Flávio: precisamos da uma coluna chamada continente? Fiquei na dúvida
### na ultima versão que eu fiz eu havia retirado, realmente não agrega, vou comentar
#coffee$continent <-
#  countrycode(sourcevar = coffee$country_of_origin,
#              origin = "country.name", destination = "continent")
#---------------------------------------------------------------------
view(coffee)
#Removendo a coluna unit_of_measurement (não precisaremos dela)
coffee <- subset(coffee, select = -c(unit_of_measurement))
#---------------------------------------------------------------------
# não entendo a inclusão de "idade"
## Comentário Flávio: acho que não faz sentido também. Aí deixei comentado.
# Adding a new column called "Age"
#df <- mutate(df, Age = c(25, 30, 22, 28, 35))
#---------------------------------------------------------------------
## Criar a coluna chamada Grade com a classificação dos cafés
## Critério:
## < 70 - Ruim (será 0)
## 70>= e < 80 - Bom (será 1)
## 80>= e < 85 - Muito Bom (será 2)
## 85 >= - Excelente (será 3)
coffee$grade <- cut(coffee$total_cup_points,
breaks = c(-Inf, 70, 80, 85, Inf),
labels = c(0, 1, 2, 3),
right = FALSE)
# Proporção de café por faixa de score
contagem_faixas <- table(coffee$grade)
barplot(prop.table(contagem_faixas) * 100, main = "Porcentagem de Faixa de score",
xlab = "Faixa de score", ylab = "Porcentagem", col = "green")
# Gráfico com o % de variáveis NA
colunas_na <- colSums(is.na(coffee))
info_na <- colunas_na[colunas_na > 0] # 4 colunas com NA
porcent_NA <- info_na / nrow(coffee) * 100
info_na
# Calculando a matriz de correlação
dados <- coffee
colunas_nao_numericas <- sapply(dados, class) != "numeric"
dados_numericos <- dados[, !colunas_nao_numericas]
matrix_de_correlacao <- cor(dados_numericos)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 45)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 100)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 500)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 5)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 5000)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 100)
coffee_grade <- subset(coffee, select = -c(aroma,flavor,
aftertaste,acidity,body,balance,
uniformity,clean_cup,sweetness,
cupper_points))
coffee_cluster <- subset(coffee, select = c(total_cup_points,aroma,flavor,
aftertaste,acidity,body,balance,
uniformity,clean_cup,sweetness,
cupper_points))
view(coffee_grade)
coffee_grade <- subset(coffee, select = -c(total_cup_points,aroma,flavor,
aftertaste,acidity,body,balance,
uniformity,clean_cup,sweetness,
cupper_points))
view(coffee_grade)
set.seed(123)
split <- initial_split(coffee_grade, prop = .70)
treino <- training(split)
teste  <- testing(split)
receita <- recipe(grade ~ ., data = treino) %>%
step_normalize(all_numeric(), -all_outcomes()) %>%
step_dummy(all_nominal(), -all_outcomes())
(receita_prep <- prep(receita))
treino_proc <- bake(receita_prep, new_data = NULL)
teste_proc <- bake(receita_prep, new_data = teste)
lm <- linear_reg() %>% set_engine("lm")
lm_fit <- linear_reg() %>%
set_engine("lm") %>%
fit(total_cup_points ~ ., treino_proc)
lm_fit <- linear_reg() %>%
set_engine("lm") %>%
fit(grade ~ ., treino_proc)
boost <- boost_tree(trees = tune(), min_n = tune(),
tree_depth = tune(), learn_rate = tune()) %>%
set_engine("xgboost") %>%
set_mode("regression")
set.seed(123)
cv_split <- vfold_cv(treino, v = 5)
boost_grid <- tune_grid(boost,
receita,
resamples = cv_split,
grid = 30,
metrics = metric_set(rmse, mae))
cv_split <- vfold_cv(treino, v = 5)
boost_grid <- tune_grid(boost,
receita,
resamples = cv_split,
grid = 30,
metrics = metric_set(rmse, mae))
best <- boost_grid %>%
select_best("rmse")
# Calculando a matriz de correlação
dados <- coffee
colunas_nao_numericas <- sapply(dados, class) != "numeric"
dados_numericos <- dados[, !colunas_nao_numericas]
matrix_de_correlacao <- cor(dados_numericos)
options(repr.plot.width = 8, repr.plot.height = 8)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 100)
options(repr.plot.width = 16, repr.plot.height = 16)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 50)
options(repr.plot.width = 32, repr.plot.height = 32)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 50)
# Calculando a matriz de correlação
dados <- coffee_grade
colunas_nao_numericas <- sapply(dados, class) != "numeric"
dados_numericos <- dados[, !colunas_nao_numericas]
matrix_de_correlacao <- cor(dados_numericos)
options(repr.plot.width = 32, repr.plot.height = 32)
corrplot(matrix_de_correlacao, method = "color", type = "upper", tl.col = "black", tl.srt = 50)
